\renewcommand{\tex}[1]{40-growth-bundle/#1}

\section{Strictly Increasing Discrete Concave WCETO of Tasks Scheduled
  by \bundle{} and \bundlep{}}
\label{sec:bundle-growth}

Motivation for this work stems from the \bundle{}~\cite{Tessler:2016}
and \bundlep{}~\cite{Tessler:2018} scheduling algorithms. Both
\bundle{} and \bundlep{} are thread-level uniprocessor scheduling
algorithms for tasks which release multiple threads with each job. The
scheduling algorithms treat the cache as a benefit, guaranteeing a
quantifiable set of values in the cache shared between threads of the
same job, which reduces run-time and worst-case execution time values. 

Execution time analysis for \bundle{} and \bundlep{} is termed the
worst-case execution time combined with cache overhead
(WCETO). For a multi-threaded task \task{i}, WCETO analysis produces
a function ${c_i(m_i)}$, bounding the execution time of ${m_i}$
threads released for each job of \task{i} scheduled by the respective
bundle algorithm (\bundle{} or \bundlep{}). Incorporated into the
bound is the inter-thread cache benefit, which reduces the WCETO of
multiple threads when compared to their single threaded cost,
ie. ${c_i(2) \le c_i(1) + c_i(1)}$.

For inclusion in the task set specification, the WCETO 
functions for \texttt{BUNDLE}-based scheduling analysis must be
strictly increasing discrete and concave, satisfying
Property~\ref{prop:wcet-growth}. Under \texttt{BUNDLE}-based
scheduling any increase in ${m_i}$ must increase 
${c_i(m_i)}$, since an additional thread of \task{i} must execute for
some time on the shared processor. Therefore, WCETO functions are
strictly increasing. As a property of \texttt{BUNDLE} scheduling and
WCETO calculation fractional threads may not be provided to
${c_i(m_i)}$, thus ${c_i(m_i)}$ is discrete.

In the WCETO analysis of \bundle{} and \bundlep{}, threads are
assigned to paths through the conflict-free region graph of the
executable object which maximize their contribution to
${c_i(m_i)}$ . When considering the addition of a thread ${m_i + 1}$,
only the greatest increase in ${c_i(m_i)}$ is permitted. Subsequently,
the addition of thread ${m_i + 2}$ must increase ${c_i(m_i)}$ by less
than or equal to the increase from ${m_i + 1}$ or the increase of
${m_i + 1}$ would not have been maximal. Therefore, for any ${m_a <
  m_b < m_c}$ the point ${(m_b, c_i(m_b))}$ lies above the straight line
described by ${(m_a, c_i(m_a))}$ and ${(m_c, c_i(m_c))}$ --
subsequently, ${c_i(m_i)}$ is concave.

For \bundle{}, the WCETO functions are strictly increasing discrete
and concave. For \bundlep{}, which considers the impact of
thread-level context switches, analysis may produce convex functions
which are strictly increasing and discrete. Under \bundlep{} analysis,
a convex ${c_i(m_i)}$ function for a task \task{i} indicates that the
inter-thread cache benefit is less than required thread-level context
switch cost on the target architecture and is not suitable for
\bundlep{} scheduling.

For a task \task{i} with convex ${c_i(m_i)}$ function, inclusion of
\task{i} in the task set specification of this work requires ${m_i =
  1}$. This forces ${c_i(m_i)}$ to be vacuously concave over the set
${\{1\}}$. It is a practical and reasonable requirement for three
reasons. First, \bundlep{} analysis must be run before submission to
\tpj{} and the concavity of any ${c_i(m_i)}$ known apriori. Second, the
least demand of ${m_i}$ threads is ${m_i \cdot c(1)}$, or one thread
per job of ${m_i}$ jobs. Lastly, providing a convex ${c_i(m_i)}$
function with ${m_i > 1}$ to the \tpj{} algorithm may result in an
incorrect infeasible result.

\texttt{BUNDLE}-based analysis produces strictly increasing discrete
concave WCETO functions. When the WCETO functions are convex,
restricting jobs to one thread per job converts them to trivially
concave functions. As such, \texttt{BUNDLE}-based WCETO functions are
suitable for \tpj{} analysis, where jobs are scheduled
non-preemptively by EDF and threads within jobs are scheduled by a
\texttt{BUNDLE}-based scheduling algorithm. 
