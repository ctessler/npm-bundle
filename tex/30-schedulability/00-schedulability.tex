\renewcommand{\tex}[1]{30-schedulability/#1}

\section{Non-Preemptive EDF Schedulability}\label{sec:schedulability}

Preemptive earliest deadline first (EDF) schedulability analysis for
sporadic task sets has been well
studied~\cite{Liu:1973,Baruah:1990,George:1996}. In the fully 
preemptive setting for which the algorithm is optimal, the
overhead of a large number of preemptions may be a detriment to
schedulability. Baruah~\cite{Baruah:2005} addresses this concern with
an algorithm for calculating the non-preemptive chunk size ${q_i}$ of
each task ${\task{i} \in \tasks}$. The non-preemptive chunk size
${q_i}$ guarantees that task \task{i} may execute up to ${q_i}$ time
units non-preemptively without introducing a deadline miss for any
task in \tasks{} scheduled by preemptive EDF.

Section~\ref{sec:tpj} introduces the non-preemptive feasibility algorithm
Thread Per Job (\tpj) based upon the non-preemptive chunks algorithm
from~\cite{Baruah:2005}. \tpj{} differs from the non-preemptive chunks
algorithm by requiring the non-preemptive chunk size ${q_i}$ of each
task \task{i} to be greater than or equal to its WCET: ${c_i(m_i) \le
  q_i}$. As such, all jobs can be scheduled non-preemptively without
fear of a deadline miss. To clearly convey \tpj{}, a description of
the non-preemptive chunks algorithm and its dependencies is provided
in the immediate subsection. Subsection~\ref{sec:improve-np-chunk}
describes, by example, the available improvements to the
non-preemptive chunks algorithm~\cite{Baruah:2005}.
Subsection~\ref{sec:feasibility} defines and proves \tpj{}'s
optimality.

\subsection{Non-Preemptive Chunks}

The non-preemptive chunks algorithm depends on the demand bound
function, EDF feasibility, ordering of absolute deadlines, and slack
for the task set ${\tasks}$. Ordered absolute deadlines are given by
${\{\Deadline{1}, \Deadline{2},   ... \}}$ with ${D_n < D_{n+1}}$
for all ${n}$, where each task ${\task{i} \in \tasks}$ contributes
deadlines ${D = k \cdot p_i + d_i}$ for ${k \in \mathbb{Z}^+}$. 

For a sporadic task \task{i} the demand bound function for a task
\dbf{\task{i}}{${t}$} is an upper bound on the amount of execution
requirement generated from jobs released by \task{i} over ${t}$ units
of time. The demand bound function is presented as
Equation~\ref{eq:dbf} as \dbf{\task{i}}{${t}$} modified
from~\cite{Baruah:1990} to suit the task set model used in this work.

\begin{definition}[Demand Bound Function for a Task \task{i} and
    Interval ${t}$]
  \begin{equation}
    \label{eq:dbf}
    \dbf{\task{i}}{${t}$} = \max \left(0,
      \left( \left\lfloor \frac{t - d_i}{p_i} \right\rfloor + 1
      \right) \cdot c_i(m_i)
    \right)
  \end{equation}
\end{definition}

When necessary for brevity, Equation~\ref{eq:dbf-sum} will be used to
represent the sum of demand of all tasks over an interval of length
${t}$.

\begin{definition}[Demand Bound Function for the Task Set \tasks{} and
    Interval ${t}$] 
  \begin{equation}
    \label{eq:dbf-sum}
    \dbf{\tasks{}}{$t$} = \sum_{\task{i} \in \tasks} \dbf{\task{i}}{$t$}
  \end{equation}
\end{definition}


Slack of the task set \tasks{} at deadline \Deadline{k} is given by
Equation~\ref{eq:slack}. Intuitively, slack is the minimum time the
processor will be idle over an interval. It is the difference between
the demand over the interval and the length of the interval.

\begin{definition}[Slack at Deadline ${D_k}$]
  \begin{equation}
    \label{eq:slack}
    \slack{${D_k}$} = \min_{j \le k}
      \left( D_j - \sum_{\task{i} \in \tasks} \dbf{\task{i}}{\Deadline{k}}
      \right)
  \end{equation}
\end{definition}

For EDF, feasibility is determined by examining increasing time
intervals and calculating the demand and supply. If demand exceeds
supply, the system is infeasible. Equation~\ref{eq:dbf-set} provides a
formal definition of feasibility for the task set \tasks{}.

\begin{definition}[EDF Feasibility Demand Bound Test]
  \begin{equation}
    \label{eq:dbf-set}
      \forall t \ge 0, 
      \left(
        \sum_{\task{i} \in \tasks{}} \dbf{\task{i}}{$t$}
      \right)
      \le t
  \end{equation}
\end{definition}

In~\cite{Baruah:2005}, the number of time instants tested by
Equation~\ref{eq:dbf-set} is limited to the values of the ordered set
of absolute deadlines ${\{D_1, D_2, ... \}}$. The ordered set of
absolute deadlines is an infinite set, impractical for feasibility
test. There is an upper bound on the value of all time instants
(absolute deadlines) that must be tested and is denoted
${T^*(\tasks{})}$. Taken from~\cite{George:1996}, ${T^*(\tasks{})}$ is given by
Equation~\ref{eq:t-star} below. Among all tasks the largest deadline
is ${d_{\text{max}} = \max_{\task{j} \in \tasks}(d_j)}$. Utilization of \task{j} is defined as ${U_j =
  \frac{c_j(m_j)}{p_j}}$. Among all tasks, the greatest difference of
period and deadline is given by ${\pd = \max_{\tau_i \in \tau}(p_i -
  d_i )}$.  The hyper-period of all tasks (the least common multiple
of all relative deadlines) is given by ${P}$.

\begin{definition}[Feasibility Test Bound ${t}$ for \tasks{}] 
  \begin{equation}\label{eq:t-star}
    T^*(\tasks{}) = \min \left(P,
    \max \left(
    d_{\text{max}}, \frac{1}{1 - U}
    \cdot \pd \cdot
    \sum_{i=0}^{n-1} U_i
    \right)
    \right)
  \end{equation}
\end{definition}

The non-preemptive chunks algorithm from~\cite{Baruah:2005} is
presented (with additional details) as pseudocode in
Algorithm~\ref{alg:np-chunks} and named \npchunks{}. In addition to
determining if the task set is schedulable under EDF, the algorithm
produces a non-preemptive chunk size ${q_j}$ for each task ${\task{j}
  \in \tasks}$. Jobs of \task{j} may execute up to ${q_j}$ time units
non-preemptively without negatively impacting schedulability. This
setting, where a task \task{j} may execute non-preemptively for some
period of time ${q_j}$ is referred to as \emph{limited-preemption}. 

\input{\tex{03-np-chunks}}

For a detailed description of \npchunks{} refer
to~\cite{Baruah:2005}. To summarize, \npchunks{} begins by seeding the
slack of the smallest interval ${D_1}$ and the non-preemptive chunk
size of tasks with the smallest relative deadline equal to their
WCET. During each iteration of ${D_k \in \{D_2, D_3, ..., \}}$, the
slack for the interval ${D_k}$ is calculated as the minimum of the
current slack and the previous slack value. If there is less than zero
slack, the system is infeasible. If the slack is zero or greater, each
task with relative deadline equal to the current interval size is
assigned the available slack as the task's non-preemptive chunk
size. A task ${\task{j}}$ is assigned a non-preemptive chunk once,
before assignment ${q_j = \varnothing}$ afterwards ${q_j \not = 
  \varnothing}$. If the interval being examined ${D_k}$ exceeds
${T^*(\tasks{})}$, the task set must be schedulable.  

\input{\tex{05-improve-npchunks}}
\input{\tex{10-threads-per-job.tex}}

\subsection{Non-Preemptive Feasibility of \tpj{} and \texdivide{}}
\label{sec:feasibility}

The \texdivide{} Algorithm~\ref{alg:divide} creates a partial task set
\Partial{j} for an anterior task \ant{j}, assigning as many threads to
each task in \Partial{j} as possible. Upon returning \Partial{j} to
\tpj{}, \ant{j} is replaced in the task set \tasks{}.
Algorithm~\ref{alg:divide} is one method of dividing of \ant{j} which
\tpj{} could employ when creating the posterior task set
\tasks{}. This section justifies \texdivide{}'s method
by demonstrating the effect on schedulability and optimality of
\tpj{}.

This section's ultimate objective is to clearly convey
Theorem~\ref{thm:tpj-optimal}; concluding that \tpj{} is optimal with
respect to task-level non-preemptive multi-threaded feasibility. The
theorems that precede Theorem~\ref{thm:tpj-optimal} establish minimal
demand and WCET sums for partial sets created by \texdivide{}
necessary to illustrate \tpj{}'s optimality.

\input{\tex{70-def-mnp-feasibile.tex}}

For the theorems that follow, unless necessary to discriminate between
anterior and posterior tasks, the anterior task \ant{i} will be
written \task{i}. The sum of the demand of the partial tasks of
\task{i} for an interval of length ${t}$ is ${\sum_{\task{k} \in
    \Phi_i} \dbf{\task{k}}{$t$}}$.  

\newcounter{__lastdef} % Definition Counter
\setcounter{__lastdef}{\value{theorem}}
\setcounter{theorem}{0} % corollary is on the theorem counter :-(

\input{\tex{40-thm-demand.tex}}

\newcounter{__lasttheorem} % Theorem Counter
\setcounter{__lasttheorem}{\value{theorem}}
\setcounter{theorem}{\value{__lastdef}}
\begin{definition}[Assumptions of Theorem~\ref{thm:tpj-wcet-sum}]
  \label{def:assumptions}
  For the following theorem, there are several assumptions that
  must be upheld for the result to be valid. These assumptions are
  consequences of the non-preemptive setting and requirements of the
  task set specification. 
  
  \begin{enumerate}
  \item All tasks \task{i} must be characterized by strictly increasing
    discrete concave WCET function ${c_i(m_i)}$.
  \item Any task ${\task{i} \in \tasks{}}$ where ${c_i(m_i) > q_i}$ is
    not schedulable non-preemptively. Consequently, no assignment of
    ${m_i}$ may cause ${c_i(m_i) > q_i}$ or the task set is infeasible.
  \item The greatest number of threads assigned to a task \task{i}
    such that ${c_i(m_i) \le q_i}$ is named
    ${m = \underset{m \in \mathbb{Z}^+}\argmax \left(c_i(m) \le q_i
      \right)}$.
  \end{enumerate}
\end{definition}

\setcounter{__lastdef}{\value{theorem}}
\setcounter{theorem}{\value{__lasttheorem}}

\input{\tex{50-thm-min-wcet.tex}}

% Theorem - TPJ minimal demand of divided tasks over all intervals
% \input{\tex{60-thm-min-demand.tex}}

\setcounter{__lasttheorem}{\value{theorem}}

\setcounter{theorem}{\value{__lastdef}}
% \input{\tex{70-def-mnp-feasibile.tex}}

\setcounter{theorem}{\value{__lasttheorem}}
\input{\tex{80-thm-tpj-npm-feasibility.tex}}
% \input{\tex{70-thm-optimal.tex}}
